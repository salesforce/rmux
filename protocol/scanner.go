/*
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this list of conditions and the following
 *   disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * * Neither the name of Salesforce.com nor the names of its contributors may be used to endorse or promote products
 *   derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package protocol

import (
	"bytes"
	"io"
)

// A partially-built scanner that can handle >64kb
type RespScanner struct {
	r     io.Reader
	token []byte
	tmp [2048]byte // temp read buffer
	b *bytes.Buffer
	err   error

	empties int
}

func NewRespScanner(r io.Reader) *RespScanner {
	return &RespScanner{
		r: r,
		b: new(bytes.Buffer),
	}
}

func (s *RespScanner) Scan() bool {
	for {
		if s.b.Len() > 0 || s.err != nil {
			// See if we can get a token with what we already have.
			advance, token, err := ScanResp(s.b.Bytes(), s.err != nil)

			if err != nil {
				s.setErr(err)
				return false
			}

			if !s.advance(advance) {
				return false
			}

			s.token = token
			if token != nil {
				if s.err == nil || advance > 0 {
					s.empties = 0
				} else {
					// Returning tokens not advancing input at EOF.
					s.empties++
					if s.empties > 100 {
						panic("rmux.protocol.Scanner: 100 empty tokens without progressing")
					}
				}

				return true
			}
		}

		// We cannot generate a token with what we are holding.
		// If we've already hit EOF or an I/O error, we are done.
		if s.err != nil {
			return false
		}

		// Time to read data.
		for loop := 0; ; {
			n, err := s.r.Read(s.tmp[:])

			if err != nil {
				s.setErr(err)
				break
			}

			s.b.Write(s.tmp[:n])

			if n > 0 {
				s.empties = 0
				break
			}

			loop++
			if loop > 100 {
				s.setErr(io.ErrNoProgress)
				break
			}
		}
	}
}

func (s *RespScanner) setErr(err error) {
	if s.err == nil || s.err == io.EOF {
		s.err = err
	}
}

func (s *RespScanner) Err() error {
	// EOF is an expected error when dealing with streams
	if s.err == io.EOF {
		return nil
	}
	return s.err
}

func (s *RespScanner) advance(n int) bool {
	s.b.Next(n)
	return true
}

// Returns the most recent token generated by a successful call to Scan()
// The array's contents may be invalid on the next call to scan, make sure
// to copy it somewhere safe.
func (s *RespScanner) Bytes() []byte {
	return s.token
}
